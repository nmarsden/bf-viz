<!DOCTYPE html>
<html lang="en">
	<head>
		<title>bf-viz</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<script src="lib/three.min.js"></script>
		<script src="lib/Detector.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="fonts/helvetiker_bold.typeface.js"></script>
		<script src="fonts/helvetiker_regular.typeface.js"></script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

            var textMaterial;

			var camera, cameraTarget, scene, renderer;

			var group;

			//var text = "  0  12  34 156  78 255   0   0   0   0",

			var targetRotation = 0;
			var targetRotationOnMouseDown = 0;

			var mouseX = 0;
			var mouseXOnMouseDown = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var y_diff = 0.1;

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

                // CAMERA

                camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 1500 );

                //camera.position.set( 0, 0, 700 );
				//cameraTarget = new THREE.Vector3( 0, 0, 0 );

                camera.position.set( 0, 100, 700 );
				cameraTarget = new THREE.Vector3( 0, 20, 0 );

				// SCENE

				scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0x000000, 450, 1400 );

				// LIGHTS

				var dirLight = new THREE.DirectionalLight( 0xffffff, 0.125 );
				dirLight.position.set( 0, 0, 1 ).normalize();
				scene.add( dirLight );

				var pointLight = new THREE.PointLight( 0xffffff, 1.5 );
				pointLight.position.set( 0, 100, 90 );
                pointLight.color.setHSL( 0.6, 1, 0.5 );
                scene.add( pointLight );

                var ambientLight = new THREE.AmbientLight( 0x404040 );
                scene.add( ambientLight );

                // MESHES

				textMaterial = new THREE.MeshFaceMaterial( [
					new THREE.MeshPhongMaterial( {
                        color: 0xffffff, shading: THREE.FlatShading } ), // front
					new THREE.MeshPhongMaterial( {
                        color: 0xffffff, shading: THREE.SmoothShading } ) // side
				] );
                var boxMaterial = new THREE.MeshPhongMaterial( {
                    color: 0x00ff00, opacity: 0.5, transparent: true } );

				group = new THREE.Group();
                group.position.y = 0;

                for (var cellNum=0; cellNum<10; cellNum++) {

                    var memoryCellGroup = new THREE.Group();
                    memoryCellGroup.name = "memCellGroup" + cellNum;
                    memoryCellGroup.add( createText( "memText", "255", textMaterial ) );
                    memoryCellGroup.add( createBox( boxMaterial ) );
                    memoryCellGroup.position.x = (55 * cellNum) - 275;

                    group.add(memoryCellGroup);
                }

				scene.add( group );
                scene.add( createPlane() );

				// RENDERER

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setClearColor( 0x000000 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				// STATS

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				// EVENT

				document.addEventListener( 'mousedown', onDocumentMouseDown, false );

				window.addEventListener( 'resize', onWindowResize, false );
			}

            function createPlane() {
                var plane = new THREE.Mesh(
                        new THREE.PlaneBufferGeometry( 10000, 10000 ),
                        new THREE.MeshBasicMaterial( {
                            color: 0x006600 //, opacity: 0.9, transparent: true
                        } )
                );
                plane.position.y = -10;
                plane.rotation.x = - Math.PI / 2;
                return plane;
            }

			function createText(name, text, material) {

				var textGeo = new THREE.TextGeometry( text, {

					size: 15,
					height: 10,
					curveSegments: 4,
					font: "helvetiker",
					weight: "bold",
					style: "normal",
					bevelThickness: 2,
					bevelSize: 1.5,
					bevelEnabled: true,

					material: 0,
					extrudeMaterial: 1

				});

				textGeo.computeBoundingBox();
				textGeo.computeVertexNormals();

				var centerOffset = -0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );

				var textMesh1 = new THREE.Mesh( textGeo, material );

                textMesh1.name = name;
                textMesh1.userData = { memValue: parseInt(text, 10) };
				textMesh1.position.x = centerOffset;
				textMesh1.position.y = 15;
				textMesh1.position.z = -5;

				textMesh1.rotation.x = 0;
				textMesh1.rotation.y = Math.PI * 2;

                return textMesh1;
			}

            function createBox(material) {

                var geometry = new THREE.BoxGeometry( 50, 50, 50 );
                var box = new THREE.Mesh( geometry, material );
                box.position.y = 25;
                return box;
            }

//			function refreshText() {
//
//				group.remove( textMesh1 );
//
//				if ( !text ) return;
//
//				createText();
//			}


            function onWindowResize() {

                windowHalfX = window.innerWidth / 2;
                windowHalfY = window.innerHeight / 2;

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );
            }

			function onDocumentMouseDown( event ) {

				event.preventDefault();

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mouseup', onDocumentMouseUp, false );
				document.addEventListener( 'mouseout', onDocumentMouseOut, false );

				mouseXOnMouseDown = event.clientX - windowHalfX;
				targetRotationOnMouseDown = targetRotation;
			}

			function onDocumentMouseMove( event ) {

				mouseX = event.clientX - windowHalfX;

				targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.02;
			}

			function onDocumentMouseUp( event ) {

				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
			}

			function onDocumentMouseOut( event ) {

				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();
			}

            function updateMemoryCell() {
                var memCellGroup = scene.getObjectByName("memCellGroup5");
                var memText = memCellGroup.getObjectByName("memText");

                var memValue = memText.userData.memValue;
                var newMemValue = (memValue + 1) % 255;

                var newMemText = createText( "memText", newMemValue+"", textMaterial );
                memCellGroup.remove(memText);
                memCellGroup.add(newMemText);
            }

			function render() {
				group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;

				if (group.position.y >= 120 || group.position.y <= 80) {
					y_diff = -y_diff;
				}
				//group.position.y += y_diff;

                // Update memory cell
                //updateMemoryCell();

				camera.lookAt( cameraTarget );

				renderer.clear();
				renderer.render( scene, camera );
			}

            // Brainfuck interpreter
            // Source: https://code.google.com/p/jslibs/wiki/JavascriptTips
            /*
            var code = '++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.';
            var inp = '23\n';
            var out = '';

            var codeSize = code.length;
            var i = 0, ip = 0, cp = 0, dp = 0, m = {};

            var loopIn = {}, loopOut = {};
            var tmp = [];
            for ( var cp = 0; cp < codeSize ; cp++ )
                if ( code[cp] == '[' )
                    tmp.push(cp);
                else
                if ( code[cp] == ']' )
                    loopOut[loopIn[cp] = tmp.pop()] = cp;

            for (var cp = 0; cp < codeSize && i < 100000; cp++, i++) {

                switch(code[cp]) {

                    case '>': dp++; break;
                    case '<': dp--; break;
                    case '+': m[dp] = ((m[dp]||0)+1)&255; break
                    case '-': m[dp] = ((m[dp]||0)-1)&255; break;
                    case '.': out += String.fromCharCode(m[dp]); break;
                    case ',': m[dp] = inp.charCodeAt(ip++)||0; break;
                    case '[': m[dp]||(cp=loopOut[cp]); break;
                    case ']': cp = loopIn[cp]-1; break;
                }
            }
            Print(out);

            */
		</script>

	</body>
</html>
